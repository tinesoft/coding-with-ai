"""
AI-Generated Code Sample with Security Issue

Problem: User search functionality for an admin dashboard.

This code was generated by an AI assistant but contains a critical
SQL injection vulnerability.
"""

import sqlite3

def search_users(search_term, role_filter=None):
    """
    Search for users in the database by name or email.
    
    Args:
        search_term: String to search for in user names or emails
        role_filter: Optional role to filter by ('admin', 'user', 'guest')
        
    Returns:
        List of matching user records
        
    Examples:
        >>> search_users("john")
        [{'id': 1, 'name': 'John Doe', 'email': 'john@example.com', 'role': 'user'}]
        >>> search_users("admin", role_filter="admin")
        [{'id': 2, 'name': 'Admin User', 'email': 'admin@example.com', 'role': 'admin'}]
    """
    # Connect to database
    conn = sqlite3.connect('users.db')
    conn.row_factory = sqlite3.Row
    cursor = conn.cursor()
    
    # SECURITY ISSUE: SQL Injection vulnerability
    # Building SQL query with string concatenation instead of parameterized queries
    query = f"SELECT id, name, email, role FROM users WHERE name LIKE '%{search_term}%' OR email LIKE '%{search_term}%'"
    
    # SECURITY ISSUE 2: Additional vulnerability in role filter
    if role_filter:
        query += f" AND role = '{role_filter}'"
    
    # SECURITY ISSUE 3: No input validation or sanitization
    # An attacker could inject: "' OR '1'='1" to bypass filters
    # Or: "'; DROP TABLE users; --" to delete data
    
    try:
        cursor.execute(query)
        results = cursor.fetchall()
        
        # Convert to list of dicts
        users = []
        for row in results:
            users.append({
                'id': row['id'],
                'name': row['name'],
                'email': row['email'],
                'role': row['role']
            })
        
        return users
    
    except Exception as e:
        # SECURITY ISSUE 4: Exposing internal error details
        print(f"Database error: {e}")
        print(f"Query was: {query}")  # Leaking query structure
        return []
    
    finally:
        conn.close()


def get_user_details(user_id):
    """
    Get detailed information for a specific user.
    
    SECURITY ISSUE 5: No authentication/authorization check
    Anyone can access any user's details
    """
    conn = sqlite3.connect('users.db')
    cursor = conn.cursor()
    
    # SECURITY ISSUE 6: Another SQL injection point
    query = f"SELECT * FROM users WHERE id = {user_id}"
    
    cursor.execute(query)
    result = cursor.fetchone()
    conn.close()
    
    return result


# Demonstration of vulnerabilities
if __name__ == "__main__":
    print("SECURITY VULNERABILITY DEMONSTRATION")
    print("="*50)
    
    # Setup test database
    conn = sqlite3.connect('users.db')
    cursor = conn.cursor()
    cursor.execute('''CREATE TABLE IF NOT EXISTS users
                     (id INTEGER PRIMARY KEY, name TEXT, email TEXT, role TEXT)''')
    cursor.execute("DELETE FROM users")  # Clear existing
    cursor.execute("INSERT INTO users VALUES (1, 'John Doe', 'john@example.com', 'user')")
    cursor.execute("INSERT INTO users VALUES (2, 'Jane Admin', 'jane@example.com', 'admin')")
    cursor.execute("INSERT INTO users VALUES (3, 'Bob Guest', 'bob@example.com', 'guest')")
    conn.commit()
    conn.close()
    
    # Normal usage
    print("\n1. Normal search:")
    results = search_users("John")
    print(f"   Results: {results}")
    
    # SQL Injection Attack 1: Bypass filters
    print("\n2. SQL Injection - Bypass filter:")
    malicious_input = "' OR '1'='1"
    results = search_users(malicious_input)
    print(f"   Input: {malicious_input}")
    print(f"   Results (should be empty, returns all): {len(results)} users")
    
    # SQL Injection Attack 2: Union-based injection
    print("\n3. SQL Injection - Union attack:")
    union_attack = "' UNION SELECT id, 'HACKED', email, role FROM users WHERE '1'='1"
    try:
        results = search_users(union_attack)
        print(f"   Attack succeeded: {results}")
    except Exception as e:
        print(f"   Attack caused error: {e}")
    
    print("\n" + "="*50)
    print("VERIFICATION TASK:")
    print("1. Identify all SQL injection vulnerabilities")
    print("2. What input validation is missing?")
    print("3. What security best practices are violated?")
    print("4. How should parameterized queries be used?")
    print("5. What other security issues exist?")
