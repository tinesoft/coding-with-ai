"""
AI-Generated Code Sample with Performance Issue

Problem: Find common friends between two users in a social network.

This code was generated by an AI assistant but contains serious
performance anti-patterns that will cause problems at scale.
"""

def get_user_friends(user_id, database):
    """Fetch all friends for a given user from database."""
    query = f"SELECT friend_id FROM friendships WHERE user_id = {user_id}"
    friends = database.execute(query)
    return [f['friend_id'] for f in friends]


def get_user_details(user_id, database):
    """Fetch user details from database."""
    query = f"SELECT * FROM users WHERE id = {user_id}"
    result = database.execute(query)
    return result[0] if result else None


def find_common_friends(user1_id, user2_id, database):
    """
    Find common friends between two users.
    
    PERFORMANCE ISSUE: This implementation has O(n²) complexity and
    includes N+1 query problems that will crash with large datasets.
    
    Args:
        user1_id: First user ID
        user2_id: Second user ID
        database: Database connection
        
    Returns:
        List of common friend user objects
    """
    # PERFORMANCE ISSUE 1: N+1 query problem
    # Fetches user1's friends one by one instead of batch query
    user1_friends = get_user_friends(user1_id, database)
    user2_friends = get_user_friends(user2_id, database)
    
    common_friend_ids = []
    
    # PERFORMANCE ISSUE 2: Nested loop with O(n²) complexity
    # For each friend of user1, loops through ALL friends of user2
    for friend1 in user1_friends:
        for friend2 in user2_friends:
            if friend1 == friend2:
                common_friend_ids.append(friend1)
    
    # PERFORMANCE ISSUE 3: Another N+1 query problem!
    # Fetches details for each common friend individually
    # instead of a single batch query
    common_friends = []
    for friend_id in common_friend_ids:
        friend_details = get_user_details(friend_id, database)
        if friend_details:
            common_friends.append(friend_details)
    
    return common_friends


def get_friend_recommendations(user_id, database):
    """
    Recommend potential friends (friends of friends who aren't already friends).
    
    PERFORMANCE ISSUE: Extremely inefficient for users with many friends.
    """
    # Get user's current friends
    user_friends = get_user_friends(user_id, database)
    
    potential_friends = []
    
    # PERFORMANCE ISSUE 4: Triple nested loop! O(n³) complexity!
    # For large networks, this could iterate millions of times
    for friend_id in user_friends:
        friends_of_friend = get_user_friends(friend_id, database)
        
        for potential_friend_id in friends_of_friend:
            # Check if already a friend or already in recommendations
            is_current_friend = False
            for existing_friend_id in user_friends:
                if potential_friend_id == existing_friend_id:
                    is_current_friend = True
                    break
            
            # PERFORMANCE ISSUE 5: Linear search instead of set lookup
            is_already_recommended = False
            for recommended in potential_friends:
                if recommended == potential_friend_id:
                    is_already_recommended = True
                    break
            
            if not is_current_friend and not is_already_recommended and potential_friend_id != user_id:
                # PERFORMANCE ISSUE 6: Another database query in the loop!
                details = get_user_details(potential_friend_id, database)
                potential_friends.append(details)
    
    return potential_friends


def get_mutual_friends_count(user1_id, user2_id, database):
    """
    Get count of mutual friends between two users.
    
    PERFORMANCE ISSUE: Fetches entire datasets just to count.
    """
    # PERFORMANCE ISSUE 7: Loads all data into memory just to count
    # A simple COUNT query would be much faster
    common = find_common_friends(user1_id, user2_id, database)
    return len(common)


# Mock database for demonstration
class MockDatabase:
    def __init__(self):
        # Create test data: 1000 users, each with 50-200 friends
        import random
        self.users = [{'id': i, 'name': f'User{i}', 'email': f'user{i}@example.com'} 
                      for i in range(1, 1001)]
        
        self.friendships = []
        for user_id in range(1, 101):  # First 100 users
            friend_count = random.randint(50, 200)
            friends = random.sample(range(1, 1001), friend_count)
            for friend_id in friends:
                self.friendships.append({'user_id': user_id, 'friend_id': friend_id})
    
    def execute(self, query):
        # Simple query parser for demo
        if 'FROM friendships' in query:
            user_id = int(query.split('user_id = ')[1])
            return [f for f in self.friendships if f['user_id'] == user_id]
        elif 'FROM users' in query:
            user_id = int(query.split('id = ')[1])
            return [u for u in self.users if u['id'] == user_id]
        return []


# Performance demonstration
if __name__ == "__main__":
    import time
    
    print("PERFORMANCE ISSUE DEMONSTRATION")
    print("="*50)
    
    db = MockDatabase()
    
    print(f"\nTest database:")
    print(f"  - 1000 users")
    print(f"  - ~8000 friendships")
    print(f"  - Average 80 friends per user")
    
    # Test 1: Find common friends (small dataset)
    print("\n1. Finding common friends (user 1 and user 2):")
    start = time.time()
    common = find_common_friends(1, 2, db)
    elapsed = time.time() - start
    print(f"   Found {len(common)} common friends")
    print(f"   Time: {elapsed:.4f} seconds")
    print(f"   Database queries: ~{len(common) + 2} (N+1 problem)")
    
    # Test 2: Friend recommendations (very slow)
    print("\n2. Getting friend recommendations (user 1):")
    print("   WARNING: This will be VERY slow due to O(n³) complexity...")
    start = time.time()
    try:
        # Set a timeout since this could run for minutes
        import signal
        signal.alarm(5)  # 5-second timeout
        recommendations = get_friend_recommendations(1, db)
        signal.alarm(0)
        elapsed = time.time() - start
        print(f"   Found {len(recommendations)} recommendations")
        print(f"   Time: {elapsed:.4f} seconds")
    except:
        print(f"   TIMEOUT after 5 seconds!")
        print(f"   This demonstrates catastrophic performance issues")
    
    # Test 3: Count mutual friends (wasteful)
    print("\n3. Counting mutual friends (inefficient):")
    start = time.time()
    count = get_mutual_friends_count(1, 2, db)
    elapsed = time.time() - start
    print(f"   Count: {count}")
    print(f"   Time: {elapsed:.4f} seconds")
    print(f"   Note: Loaded all friend data just to count!")
    
    print("\n" + "="*50)
    print("VERIFICATION TASK:")
    print("1. Identify all O(n²) or worse algorithms")
    print("2. Find N+1 query problems")
    print("3. What data structures would improve performance?")
    print("   Hint: Sets for membership testing O(1) vs O(n)")
    print("   Hint: Hash maps for lookups")
    print("   Hint: Batch database queries")
    print("4. How should this be optimized?")
    print("   - Use set intersection for common friends: O(n)")
    print("   - Batch database queries to avoid N+1")
    print("   - Use COUNT queries instead of fetching data")
    print("   - Use hash-based lookups instead of nested loops")
    print("5. Estimate performance with 10,000 users:")
    print("   Current: Minutes to hours")
    print("   Optimized: Milliseconds")
