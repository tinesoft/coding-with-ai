"""
AI-Generated Code Sample with Testability Issue

Problem: Process and send customer order confirmations.

This code was generated by an AI assistant but is extremely difficult
to unit test due to tight coupling and hard-coded dependencies.
"""

import smtplib
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
import sqlite3
from datetime import datetime
import os


class OrderProcessor:
    """
    Process customer orders and send confirmations.
    
    TESTABILITY ISSUES:
    - Hard-coded database connection
    - Hard-coded email service
    - Direct file system access
    - No dependency injection
    - Mixed concerns (business logic + infrastructure)
    - Difficult to mock external services
    """
    
    def process_order(self, order_id):
        """
        Process an order and send confirmation email.
        
        TESTABILITY ISSUE 1: Hard-coded database dependency
        Cannot test without a real database connection
        """
        # Create database connection directly - can't be mocked!
        conn = sqlite3.connect('/var/data/production.db')
        cursor = conn.cursor()
        
        # TESTABILITY ISSUE 2: SQL query embedded in business logic
        cursor.execute(f"SELECT * FROM orders WHERE id = {order_id}")
        order = cursor.fetchone()
        
        if not order:
            conn.close()
            return False
        
        # TESTABILITY ISSUE 3: Another hard-coded database call
        cursor.execute(f"SELECT * FROM customers WHERE id = {order[1]}")
        customer = cursor.fetchone()
        
        # TESTABILITY ISSUE 4: Hard-coded file system access
        # Cannot test without creating actual files
        log_file = open('/var/log/orders.log', 'a')
        log_file.write(f"{datetime.now()}: Processing order {order_id}\n")
        log_file.close()
        
        # TESTABILITY ISSUE 5: Hard-coded email service
        # Cannot test email sending without SMTP server
        smtp_server = smtplib.SMTP('smtp.gmail.com', 587)
        smtp_server.starttls()
        smtp_server.login('noreply@company.com', 'hardcoded_password!')  # ALSO A SECURITY ISSUE!
        
        # Create email
        msg = MIMEMultipart()
        msg['From'] = 'noreply@company.com'
        msg['To'] = customer[2]  # Customer email
        msg['Subject'] = 'Order Confirmation'
        
        body = f"Your order #{order_id} has been processed."
        msg.attach(MIMEText(body, 'plain'))
        
        smtp_server.send_message(msg)
        smtp_server.quit()
        
        # TESTABILITY ISSUE 6: More hard-coded file access
        receipt_path = f'/var/receipts/order_{order_id}.txt'
        with open(receipt_path, 'w') as f:
            f.write(f"Order ID: {order_id}\n")
            f.write(f"Customer: {customer[1]}\n")
            f.write(f"Total: ${order[3]}\n")
        
        # Update database
        cursor.execute(f"UPDATE orders SET status = 'processed' WHERE id = {order_id}")
        conn.commit()
        conn.close()
        
        return True
    
    
    def calculate_shipping_cost(self, order_id):
        """
        Calculate shipping cost for an order.
        
        TESTABILITY ISSUE 7: Calling external API directly
        """
        # Hard-coded database access again
        conn = sqlite3.connect('/var/data/production.db')
        cursor = conn.cursor()
        cursor.execute(f"SELECT weight, destination FROM orders WHERE id = {order_id}")
        order_data = cursor.fetchone()
        conn.close()
        
        # TESTABILITY ISSUE 8: Hard-coded external HTTP call
        # Cannot test without hitting real shipping API
        import requests
        response = requests.post(
            'https://api.shippingcompany.com/calculate',
            json={'weight': order_data[0], 'destination': order_data[1]},
            headers={'API-Key': 'sk_live_123456789'}  # Hard-coded secret!
        )
        
        return response.json()['cost']
    
    
    def send_notification(self, customer_id, message):
        """
        Send notification to customer.
        
        TESTABILITY ISSUE 9: Multiple hard-coded dependencies
        """
        # Hard-coded database
        conn = sqlite3.connect('/var/data/production.db')
        cursor = conn.cursor()
        cursor.execute(f"SELECT phone, email FROM customers WHERE id = {customer_id}")
        customer = cursor.fetchone()
        conn.close()
        
        # TESTABILITY ISSUE 10: Hard-coded SMS service
        from twilio.rest import Client
        client = Client('AC123456789', 'auth_token_hardcoded')
        client.messages.create(
            to=customer[0],
            from_='+15555555555',
            body=message
        )
        
        # TESTABILITY ISSUE 11: Hard-coded email (again)
        smtp_server = smtplib.SMTP('smtp.gmail.com', 587)
        smtp_server.starttls()
        smtp_server.login('noreply@company.com', 'password')
        # ... email sending code ...
        smtp_server.quit()
        
        return True


# This class is IMPOSSIBLE to unit test properly because:
# 1. No dependency injection - all dependencies created internally
# 2. Hard-coded file paths - tests need specific directory structure
# 3. Hard-coded database - tests need actual database setup
# 4. Hard-coded SMTP - tests need email server or complex mocking
# 5. Hard-coded HTTP calls - tests need network or complex patching
# 6. Mixed concerns - business logic entangled with infrastructure


# Demonstration of testability problems
if __name__ == "__main__":
    print("TESTABILITY ISSUE DEMONSTRATION")
    print("="*50)
    
    print("\nAttempting to test OrderProcessor...")
    print("\nProblems encountered:")
    print("1. No way to inject mock database")
    print("2. No way to inject mock email service")
    print("3. Hard-coded file paths require specific directories")
    print("4. Hard-coded API endpoints can't be stubbed")
    print("5. Business logic mixed with infrastructure")
    print("6. Cannot test in isolation - needs full environment")
    
    print("\nWhat a unit test would need:")
    print("- Actual SQLite database at /var/data/production.db")
    print("- SMTP server at smtp.gmail.com")
    print("- Writable /var/log/ directory")
    print("- Writable /var/receipts/ directory")
    print("- Network access to shipping API")
    print("- Twilio account credentials")
    print("\nThis is NOT unit testing - this is integration testing!")
    
    print("\n" + "="*50)
    print("VERIFICATION TASK:")
    print("\n1. Identify all hard-coded dependencies:")
    print("   - Database connections")
    print("   - File system access")
    print("   - Email services")
    print("   - HTTP APIs")
    print("   - SMS services")
    
    print("\n2. How should this be refactored for testability?")
    print("   - Dependency injection (pass dependencies as parameters)")
    print("   - Interfaces/protocols for dependencies")
    print("   - Separate business logic from infrastructure")
    print("   - Configuration injection (file paths, API keys)")
    
    print("\n3. Example refactoring:")
    print("   class OrderProcessor:")
    print("       def __init__(self, database, email_service, file_system):")
    print("           self.db = database")
    print("           self.email = email_service")
    print("           self.fs = file_system")
    print("")
    print("       def process_order(self, order_id):")
    print("           order = self.db.get_order(order_id)")
    print("           # Now we can mock self.db in tests!")
    
    print("\n4. Benefits of refactoring:")
    print("   - Can test business logic in isolation")
    print("   - Fast tests (no real DB, email, or API calls)")
    print("   - Mockable dependencies")
    print("   - Easier to maintain and modify")
    
    print("\n5. Testing anti-patterns to avoid:")
    print("   - Hard-coded infrastructure dependencies")
    print("   - Direct instantiation of services inside methods")
    print("   - No interfaces or protocols for dependencies")
    print("   - Mixed business logic and infrastructure code")
    print("   - Tight coupling to specific implementations")
